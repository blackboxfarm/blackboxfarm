/**
 * CoinGecko Alert System
 * Sends notifications to Telegram and Email when CoinGecko has issues
 */

import { SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";
import type { CoinGeckoErrorInfo } from "./coingecko-error-handler.ts";

const BLACKBOX_TG_GROUP_ID = -5274739643;
const ALERT_COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes between same error type alerts

// In-memory cooldown tracker (resets on function cold start)
const lastAlertTimes: Record<string, number> = {};

export interface AlertResult {
  telegramSent: boolean;
  emailSent: boolean;
  logged: boolean;
  skippedReason?: string;
}

/**
 * Check if we should send an alert (rate limiting)
 */
function shouldSendAlert(errorInfo: CoinGeckoErrorInfo): boolean {
  const key = `${errorInfo.errorCode}_${errorInfo.endpoint}`;
  const now = Date.now();
  const lastAlert = lastAlertTimes[key] || 0;
  
  if (now - lastAlert < ALERT_COOLDOWN_MS) {
    return false;
  }
  
  lastAlertTimes[key] = now;
  return true;
}

/**
 * Format alert message for Telegram
 */
function formatTelegramMessage(errorInfo: CoinGeckoErrorInfo, context: string): string {
  const severityEmoji = {
    critical: 'üö®',
    high: '‚ö†Ô∏è',
    medium: '‚ö°',
    low: '‚ÑπÔ∏è',
  };

  const emoji = severityEmoji[errorInfo.severity] || '‚ö†Ô∏è';
  
  return `${emoji} **COINGECKO API ALERT** ${emoji}

**Error:** ${errorInfo.errorCode}${errorInfo.httpStatus ? ` (HTTP ${errorInfo.httpStatus})` : ''}
**Severity:** ${errorInfo.severity.toUpperCase()}
**Endpoint:** ${errorInfo.endpoint}
**API Tier:** ${errorInfo.tier}
**Time:** ${errorInfo.timestamp}

**Message:** ${errorInfo.message.slice(0, 200)}
${errorInfo.retryAfterSeconds ? `\n**Retry After:** ${errorInfo.retryAfterSeconds}s` : ''}

**Context:** ${context}

**Action:** System switching to Jupiter/DexScreener fallback`;
}

/**
 * Format alert message for Email
 */
function formatEmailHtml(errorInfo: CoinGeckoErrorInfo, context: string): string {
  const severityColor = {
    critical: '#dc2626',
    high: '#f59e0b',
    medium: '#3b82f6',
    low: '#6b7280',
  };

  return `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0a0a; color: #e5e5e5; padding: 20px; }
    .container { max-width: 600px; margin: 0 auto; background: #171717; border-radius: 12px; padding: 24px; }
    .header { border-bottom: 1px solid #262626; padding-bottom: 16px; margin-bottom: 16px; }
    .title { font-size: 24px; font-weight: bold; color: ${severityColor[errorInfo.severity]}; margin: 0; }
    .row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #262626; }
    .label { color: #a3a3a3; }
    .value { color: #e5e5e5; font-weight: 500; }
    .message { background: #262626; padding: 12px; border-radius: 6px; margin: 16px 0; font-family: monospace; font-size: 13px; }
    .footer { margin-top: 20px; color: #737373; font-size: 12px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="title">‚ö†Ô∏è CoinGecko API ${errorInfo.errorCode}</h1>
    </div>
    
    <div class="row">
      <span class="label">Severity</span>
      <span class="value" style="color: ${severityColor[errorInfo.severity]}">${errorInfo.severity.toUpperCase()}</span>
    </div>
    <div class="row">
      <span class="label">HTTP Status</span>
      <span class="value">${errorInfo.httpStatus || 'N/A'}</span>
    </div>
    <div class="row">
      <span class="label">Endpoint</span>
      <span class="value">${errorInfo.endpoint}</span>
    </div>
    <div class="row">
      <span class="label">API Tier</span>
      <span class="value">${errorInfo.tier}</span>
    </div>
    <div class="row">
      <span class="label">Timestamp</span>
      <span class="value">${errorInfo.timestamp}</span>
    </div>
    ${errorInfo.retryAfterSeconds ? `
    <div class="row">
      <span class="label">Retry After</span>
      <span class="value">${errorInfo.retryAfterSeconds} seconds</span>
    </div>
    ` : ''}
    <div class="row">
      <span class="label">Context</span>
      <span class="value">${context}</span>
    </div>
    
    <div class="message">${errorInfo.message}</div>
    
    <p><strong>Action:</strong> System has automatically switched to Jupiter/DexScreener fallback for price fetching.</p>
    
    <div class="footer">
      This alert was generated by the BlackBox Farm monitoring system.
    </div>
  </div>
</body>
</html>
  `;
}

/**
 * Send CoinGecko error alert to Telegram and Email
 */
export async function sendCoinGeckoAlert(
  supabase: SupabaseClient,
  errorInfo: CoinGeckoErrorInfo,
  context: string
): Promise<AlertResult> {
  const result: AlertResult = {
    telegramSent: false,
    emailSent: false,
    logged: false,
  };

  // Check if error is alertable and not rate-limited
  if (!errorInfo.shouldAlert) {
    result.skippedReason = 'Error type not configured for alerts';
    return result;
  }

  if (!shouldSendAlert(errorInfo)) {
    result.skippedReason = 'Alert cooldown active (5min between same errors)';
    console.log(`[CoinGecko Alert] Skipped: ${result.skippedReason}`);
    return result;
  }

  // 1. Log to database first (always)
  try {
    await supabase.from('coingecko_error_alerts').insert({
      error_code: errorInfo.errorCode,
      http_status: errorInfo.httpStatus,
      message: errorInfo.message,
      endpoint: errorInfo.endpoint,
      tier: errorInfo.tier,
      retry_after_seconds: errorInfo.retryAfterSeconds,
      severity: errorInfo.severity,
      context,
      notified_at: new Date().toISOString(),
    });
    result.logged = true;
    console.log('[CoinGecko Alert] ‚úì Logged to database');
  } catch (e) {
    console.error('[CoinGecko Alert] Failed to log to database:', e);
  }

  // 2. Send Telegram message
  try {
    const telegramMessage = formatTelegramMessage(errorInfo, context);
    const { error: tgError } = await supabase.functions.invoke('telegram-mtproto-auth', {
      body: {
        action: 'send_message',
        chatId: BLACKBOX_TG_GROUP_ID,
        message: telegramMessage,
      },
    });
    
    if (tgError) {
      console.warn('[CoinGecko Alert] Telegram failed:', tgError);
    } else {
      result.telegramSent = true;
      console.log('[CoinGecko Alert] ‚úì Telegram message sent');
    }
  } catch (e) {
    console.error('[CoinGecko Alert] Telegram error:', e);
  }

  // 3. Send Email
  try {
    const emailHtml = formatEmailHtml(errorInfo, context);
    const { error: emailError } = await supabase.functions.invoke('send-email-notification', {
      body: {
        to: 'admin@blackboxfarm.app', // TODO: Get from config
        subject: `‚ö†Ô∏è CoinGecko ${errorInfo.errorCode} - ${errorInfo.severity.toUpperCase()}`,
        html: emailHtml,
      },
    });
    
    if (emailError) {
      console.warn('[CoinGecko Alert] Email failed:', emailError);
    } else {
      result.emailSent = true;
      console.log('[CoinGecko Alert] ‚úì Email sent');
    }
  } catch (e) {
    console.error('[CoinGecko Alert] Email error:', e);
  }

  return result;
}

/**
 * Log a fallback activation (for analytics)
 */
export async function logFallbackActivation(
  supabase: SupabaseClient,
  originalError: CoinGeckoErrorInfo,
  fallbackSource: string,
  fallbackPrice: number,
  context: string
): Promise<void> {
  try {
    await supabase.from('coingecko_error_alerts').insert({
      error_code: originalError.errorCode,
      http_status: originalError.httpStatus,
      message: `Fallback activated: ${fallbackSource} returned $${fallbackPrice.toFixed(2)}`,
      endpoint: originalError.endpoint,
      tier: originalError.tier,
      severity: 'low',
      context,
      fallback_source: fallbackSource,
      fallback_price: fallbackPrice,
      notified_at: new Date().toISOString(),
      resolved_at: new Date().toISOString(), // Mark as resolved since fallback worked
    });
  } catch (e) {
    console.warn('[CoinGecko Alert] Failed to log fallback activation:', e);
  }
}
